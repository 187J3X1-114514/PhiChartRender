{"version":3,"file":"o.O-BKt_aEOh.js","sources":["../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","../node_modules/.pnpm/pixi.js@8.2.1/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"],"sourcesContent":["import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","import { getMaxTexturesPerBatch } from '../../batcher/gl/utils/maxRecommendedTextures.mjs';\n\n\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(getMaxTexturesPerBatch())}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(getMaxTexturesPerBatch())}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(getMaxTexturesPerBatch())}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n"],"names":["count","TexturePoolClass","textureOptions","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","Texture","frameWidth","frameHeight","resolution","po2Width","po2Height","nextPow2","key","texture","source","renderTexture","destroyTextures","i","textures","j","TexturePool","addBits","srcParts","parts","name","id","part","sanitisedPart","warn","findHooksRx","compileHooks","programSrc","hook","extractInputs","fragmentSource","out","match","regex","compileInputs","fragments","template","sort","results","fragment","mainInput","finalString","inValue","cleanedString","extractOutputs","extractVariableName","value","stripVariable","compileOutputs","index","mainStruct","mainStart","mainEnd","compiledCode","injectBits","templateSrc","fragmentParts","cacheMap","bitCacheMap","CACHE_UID","compileHighShader","bits","cacheId","generateCacheId","vertex","compileInputsAndOutputs","compileBits","compileHighShaderGl","vertexFragments","shaderBit","v","fragmentFragments","compiledVertex","compiledFragment","highFragment","a","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","GpuProgram","compileHighShaderGlProgram","GlProgram","colorBit","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","bindingIndex","generateSampleSrc","generateTextureBatchBit","getMaxTexturesPerBatch","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","roundPixelsBit","roundPixelsBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","BatchableSprite","float32View","uint32View","textureId","sprite","wt","c","d","tx","ty","bounds","w0","w1","h0","h1","uvs","argb","textureIdAndRound","indexBuffer","indicesOffset","color32BitToUniform","abgr","offset","alpha"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}